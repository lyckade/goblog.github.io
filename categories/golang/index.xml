<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Go lycka go</title>
    <link>http://lyckade.github.io/categories/golang/</link>
    <description>Recent content in Golang on Go lycka go</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de</language>
    <lastBuildDate>Tue, 17 May 2016 22:40:53 +0200</lastBuildDate>
    <atom:link href="http://lyckade.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tutorial über Model und View in einem REST Service</title>
      <link>http://lyckade.github.io/blog/2016/05/17/tutorial-%C3%BCber-model-und-view-in-einem-rest-service/</link>
      <pubDate>Tue, 17 May 2016 22:40:53 +0200</pubDate>
      
      <guid>http://lyckade.github.io/blog/2016/05/17/tutorial-%C3%BCber-model-und-view-in-einem-rest-service/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stevenwhite.com/building-a-rest-service-with-golang-2/&#34;&gt;http://stevenwhite.com/building-a-rest-service-with-golang-2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Steven White beschreibt in seinem Tutorial, wie man einen einfachen Web Server mit Go umsetzt. Dabei gliedert er seinen Code in Model und Controller. Alle Models werden dabei in einem Packet &lt;code&gt;models&lt;/code&gt; und die Controller in einem Packet &lt;code&gt;controller&lt;/code&gt; umgesetzt.&lt;/p&gt;

&lt;p&gt;Dieses Pattern ist übersichtlich und führt zu einem strukturierten Code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1605_link_rest_model_controller</title>
      <link>http://lyckade.github.io/1605_link_rest_model_controller/</link>
      <pubDate>Tue, 17 May 2016 22:40:36 +0200</pubDate>
      
      <guid>http://lyckade.github.io/1605_link_rest_model_controller/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Client tests in Golang mit httptest</title>
      <link>http://lyckade.github.io/blog/2016/05/17/client-tests-in-golang-mit-httptest/</link>
      <pubDate>Tue, 17 May 2016 10:07:30 +0200</pubDate>
      
      <guid>http://lyckade.github.io/blog/2016/05/17/client-tests-in-golang-mit-httptest/</guid>
      <description>&lt;p&gt;Bei der Erstellung von Microservices mittels eine REST API gibt es bei der Kommunikation zwischen zwei Diensten neben dem Empfänger (Server) immer auch eine sendende Seite (Client).&lt;/p&gt;

&lt;p&gt;Für das Testen von http Anfragen an einen Server bietet das &lt;a href=&#34;https://golang.org/pkg/net/http/httptest/#Server&#34;&gt;httptest Packet&lt;/a&gt; einen eigenen Testserver an. Mit der Funktion &lt;code&gt;NewServer()&lt;/code&gt; lässt sich der Testserver starten. Dabei wird eine Referenz auf eine Server instanz zurück gegeben.&lt;/p&gt;

&lt;p&gt;Der Client muss nun für den Test die richtige URL verwenden. Die Testserver URL kann über den Parameter &lt;code&gt;URL&lt;/code&gt; abgefragt werden.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// Neuen Testserver erstellen
ts := httptest.NewServer(http.HandlerFunc(
	func(w http.ResponseWriter, r *http.Request) {
		// Unterschiedliche Response Szenarien können 
		// über den Header einfach erzeugt werden. 
		w.WriteHeader(200)
		fmt.Fprintln(w, &amp;quot;Hallo Client&amp;quot;)
}))
defer ts.Close()
// URL des Servers ausgeben
fmt.Println(ts.URL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/VmZriIZhLm&#34;&gt;https://play.golang.org/p/VmZriIZhLm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Damit der Code auch testbar ist, muss beim Client die Möglichkeit bestehen die URL für die Abfrage zu manipulieren. Dafür verwendet man für das Erzeugen der URL am Besten das zugehörige &lt;a href=&#34;https://golang.org/pkg/net/url/#URL&#34;&gt;Packet URL&lt;/a&gt;. Der Datentyp URL zerlegt eine URL in folgende Teile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scheme://[userinfo@]host/path[?query][#fragment]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Durch das Setzen des Parameters &lt;code&gt;host&lt;/code&gt; kann somit nur der relevante Teil ausgetauscht werden. Bei einem GET Aufruf kann das ganze wie folgt aussehen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getInfo(url url.URL) *http.Response{
	myClient := new(http.Client)
	resp, err := myClient.Get(url.String())
	if err != nil {
		// Fehlerbehandlung
	}
	return resp

var reqURL = url.Parse(&amp;quot;http://myserver:1234/&amp;quot;)
func main(){
	resp := getInfo(reqURL)
	// Client code ...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang und die Zeit: Das magische Datum</title>
      <link>http://lyckade.github.io/blog/2016/05/15/golang-und-die-zeit-das-magische-datum/</link>
      <pubDate>Sun, 15 May 2016 15:37:02 +0200</pubDate>
      
      <guid>http://lyckade.github.io/blog/2016/05/15/golang-und-die-zeit-das-magische-datum/</guid>
      <description>

&lt;p&gt;Die Dokumentation zu dem Packet time ist bezüglich der Formatierung des Datums nicht sehr ausführlich. Deshalb soll die fast schon geniale Logik kurz vorgestellt werden.&lt;/p&gt;

&lt;h2 id=&#34;das-magische-datum&#34;&gt;Das magische Datum&lt;/h2&gt;

&lt;p&gt;Der Ansatz von go ist anders als bekannt. Die Definition des Datum-Format erfolgt dabei nicht über Flags sondern über ein fest eindeutig definiertes Datum.&lt;/p&gt;

&lt;p&gt;Die Dokumentation hat in dem Packet bereits ein paar Konstanten definiert: &lt;a href=&#34;https://godoc.org/time#pkg-constants&#34;&gt;https://godoc.org/time#pkg-constants&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ANSIC       = &amp;ldquo;Mon Jan _2 15:04:05 2006&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An den Konstanten erkennt man das magische Datum: der 2.01.2006 um 15:04:05. In einer anderen Darstellung kann man sehen, dass dies die Zahlen von 1 bis 7 sind:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;01/02 03:04:05PM &amp;lsquo;06 -0700&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Dadurch wird das jeweilige Element für die Formatierung identifieziert.&lt;/p&gt;

&lt;p&gt;Möchte ich nun einen einfachen Zeitstempel erzeugen kann ich das Layout ganz einfach mit dem Datum definieren:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const timestampLayout = &amp;quot;20060102150405&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Die Ausgabe erfolgt nun ganz einfach über &lt;code&gt;Format()&lt;/code&gt;. Das Beste an der Stelle ist, dass dies mit der Funktion &lt;code&gt;time.Parse()&lt;/code&gt;  auch in die andere Richtung funktioniert.&lt;/p&gt;

&lt;p&gt;Auf dem Playground gibt es das ganze noch einmal als komplettes Beispiel:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/n0YuYWwolV&#34;&gt;https://play.golang.org/p/n0YuYWwolV&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>